{% extends 'base.html' %}
{% block title %} Identify Activity{% endblock %}
{% block content %}
<div class="d-flex bg-primary py-2 text-white justify-content-center">Activity Identification on Yuktdhara</div>

<!-- Permissible Work Search -->
<div class="search-container pt-4 mb-2" id="permissible-search-card">
    <div class="search-box">
        <input 
            type="text" 
            class="search-input" 
            id="permissible-search" 
            placeholder="Search Permissible Work / Work Type / Major Scheduled Category..."
            autocomplete="off"
        >
        <button class="search-btn" id="permissible-search-btn" type="button" disabled>
            <i class="fas fa-search"></i>
        </button>
    </div>
</div>

<!-- Applied Filters Row -->
<div class="d-flex justify-content-between fs-8 align-items-center py-1 px-3 bg-light border-bottom invisible" id="applied-filters-row">
    <div class="d-flex flex-wrap gap-1 align-items-center">
        <span class="text-muted me-2">Applied Filters:</span>
        <div id="applied-filters-container" class="d-flex flex-wrap gap-1">
            <!-- Filter badges will be inserted here -->
        </div>
        <span id="no-filters-text" class="text-muted fst-italic">None</span>
    </div>
    <button type="button" class="btn btn-outline-danger btn-sm fs-8" id="clear-all-filters">
        <i class="fas fa-times"></i> Clear
    </button>
</div>

<!-- FIRST ROW - Original btn-group styling -->
<div class="d-flex justify-content-between">
    <div class="card flex-fill m-2 pb-3">
        <div class="card-body px-2">
            <div class="d-grid gap-2">
                <div class="fw-bold text-center">Nature of Work</div>
                <div class="btn-group" role="group" aria-label="Nature of Work selection">
                    {% for item in nature_of_work %}
                    <input type="radio" class="btn-check" name="nature_of_works" id="btn-nature_of_works-{{item.id}}" autocomplete="off" value="{{item.id}}" data-id="{{item.id}}" data-group="nature_of_works" data-label="{{item.short_name}}">
                    <label class="btn btn-outline-dark btn-sm text-center btn-text-scroll" for="btn-nature_of_works-{{item.id}}">{{ item.short_name}}</label>
                    {% endfor %}
                </div>
                <div class="fw-bold text-center">Master Category</div>
                <div class="btn-group" role="group" aria-label="Master Category selection" id="categories-container">
                    {% for item in categories %}
                    <input type="radio" class="btn-check" name="categories" id="btn-categories-{{item.id}}" autocomplete="off" value="{{item.id}}" data-id="{{item.id}}" data-group="categories" data-label="{{item.name}}">
                    <label class="btn btn-outline-dark btn-sm text-center btn-text-scroll" for="btn-categories-{{item.id}}">{{ item.name}}</label>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>
    <div class="card flex-fill m-2">
        <div class="card-body px-2">
            <div class="d-grid gap-2">
                <div class="fw-bold text-center">Ridge</div>
                <div class="btn-group flex-wrap" role="group" aria-label="Ridge selection" id="ridges-container">
                    {% for item in ridges %}
                    <input type="checkbox" class="btn-check" name="ridges" id="btn-ridges-{{item.id}}" autocomplete="off" value="{{item.id}}" data-id="{{item.id}}" data-group="ridges" data-label="{{item.name}}">
                    <label class="btn btn-outline-dark btn-sm text-center btn-text-scroll" for="btn-ridges-{{item.id}}">{{ item.name }}</label>
                    {% endfor %}
                </div>
                <div class="fw-bold text-center">Cluster</div>
                <div class="btn-group flex-wrap" role="group" aria-label="Cluster selection" id="clusters-container" style="cursor: not-allowed;">
                    {% for item in clusters %}
                    <input type="checkbox" class="btn-check" name="clusters" id="btn-clusters-{{item.id}}" autocomplete="off" value="{{item.id}}" data-id="{{item.id}}" data-group="clusters" data-label="{{item.name}}">
                    <label class="btn btn-outline-dark btn-sm text-center btn-text-scroll" for="btn-clusters-{{item.id}}">{{ item.name }}</label>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>    
    <div class="card flex-fill m-2">
        <div class="card-body px-2">
            <div class="d-grid gap-2">
                <div class="fw-bold text-center">Slope %</div>
                <div class="btn-group flex-wrap" role="group" aria-label="Slope selection" id="slopes-container">
                    {% for item in slopes %}
                    <input type="checkbox" class="btn-check" name="slopes" id="btn-slopes-{{item.id}}" autocomplete="off" value="{{item.id}}" data-id="{{item.id}}" data-group="slopes" data-label="{{item.name}}">
                    <label class="btn btn-outline-dark btn-sm text-center btn-text-scroll" for="btn-slopes-{{item.id}}">{{ item.name }}</label>
                    {% endfor %}
                </div>
                <div class="fw-bold text-center">Water Works</div>
                <div class="btn-group flex-wrap" role="group" aria-label="Water Works selection" id="water-works-container">
                    {% for item in water_works %}
                    <input type="checkbox" class="btn-check" name="water_works" id="btn-water_works-{{item.id}}" autocomplete="off" value="{{item.id}}" data-id="{{item.id}}" data-group="water_works" data-label="{{item.name}}">
                    <label class="btn btn-outline-dark btn-sm text-center btn-text-scroll" for="btn-water_works-{{item.id}}">{{ item.name}}</label>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>
    <div class="card flex-fill m-2">
        <div class="card-body px-2">
            <div class="d-grid gap-2">
                <div class="fw-bold text-center">Beneficiary Type</div>
                <div class="btn-group" role="group" aria-label="Beneficiary Type selection" id="beneficiaries-container">
                    {% for item in beneficiaries %}
                    <input type="radio" class="btn-check" name="beneficiaries" id="btn-beneficiaries-{{item.id}}" autocomplete="off" value="{{item.id}}" data-id="{{item.id}}" data-group="beneficiaries" data-label="{{item.name | capitalize}}">
                    <label class="btn btn-outline-dark btn-sm text-center btn-text-scroll" for="btn-beneficiaries-{{item.id}}">{{ item.name | capitalize}}</label>
                    {% endfor %}
                </div>
                <div class="fw-bold text-center">Activity Type</div>
                <div class="btn-group" role="group" aria-label="Activity Type selection" id="activities-container">
                    {% for item in activities %}
                    <input type="radio" class="btn-check" name="activity_types" id="btn-activity_types-{{item.id}}" autocomplete="off" value="{{item.id}}" data-id="{{item.id}}" data-group="activity_types" data-label="{{item.short_name | capitalize}}">
                    <label class="btn btn-outline-dark btn-sm text-center btn-text-scroll" for="btn-activity_types-{{item.id}}">{{ item.short_name | capitalize}}</label>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>
</div>

<!-- SECOND ROW - Option row styling -->
<div class="d-flex justify-content-between align-items-stretch" id="second-row"> 
    <div class="card  mx-2 d-flex flex-column scrollable-card">
        <div class="card-header text-center">
            <div class="d-flex justify-content-between align-items-center">
                <span>{{ "Land Type" }}</span>
                <span class="badge bg-dark" id="land-types-count">{{land_types|length}}</span>
            </div>
        </div>
        <div class="card-body d-flex flex-column">
            <div class="overflow-auto flex-fill scrollable-body">
                <div class="d-grid gap-2" id="land-types-container">
                {% for item in land_types %}
                <div class="radio-row">
                    <input type="checkbox" class="btn-check" name="location_specifics" id="btn-location_specifics-{{item.id}}" autocomplete="off" value="{{item.id}}" data-id="{{item.id}}" data-group="location_specifics" data-label="{{item.name | capitalize}}">
                    <label class="btn btn-outline-dark btn-sm full-width-label btn-text-scroll" for="btn-location_specifics-{{item.id}}">{{ item.name | capitalize}}</label>
                </div>
                {% endfor %}
                </div>
            </div>
        </div>
    </div>   
    <div class="card card-fixed mx-2 d-flex flex-column scrollable-card">
        <div class="card-header text-center">
            <div class="d-flex justify-content-between align-items-center">
                <span>{{ "Major Scheduled Category" }}</span>
                <span class="badge bg-dark" id="major-scheduled-count">{{major_scheduled_category|length}}</span>
            </div>
        </div>
        <div class="card-body d-flex flex-column">
            <div class="overflow-auto flex-fill scrollable-body">
                <div class="d-grid gap-2" id="major-scheduled-container">
                {% for item in major_scheduled_category %}
                <div class="radio-row">
                    <input type="radio" class="btn-check" name="major_scheduled_category" id="btn-major_scheduled_category-{{item.id}}" autocomplete="off" value="{{item.id}}" data-id="{{item.id}}" data-group="major_scheduled_category" data-label="{{item.name | capitalize}}">
                    <label class="btn btn-outline-dark btn-sm full-width-label btn-text-scroll" for="btn-major_scheduled_category-{{item.id}}">{{ item.name | capitalize}}</label>
                </div>
                {% endfor %}
                </div>
            </div>
        </div>
    </div>
    <div class="card card-fixed mx-2 d-flex flex-column scrollable-card">
        <div class="card-header text-center">
            <div class="d-flex justify-content-between align-items-center">
                <span>{{ "Work Type" }}</span>
                <span class="badge bg-dark" id="work-types-count">{{work_types|length}}</span>
            </div>
        </div>
        <div class="card-body d-flex flex-column">
            <div class="overflow-auto flex-fill scrollable-body">
                <div class="d-grid gap-2" id="work-types-container">
                {% for item in work_types %}
                <div class="radio-row">
                    <input type="radio" class="btn-check" name="work_types" id="btn-work_types-{{item.id}}" autocomplete="off" value="{{item.id}}" data-id="{{item.id}}" data-group="work_types" data-label="{{item.name | capitalize}}">
                    <label class="btn btn-outline-dark btn-sm full-width-label btn-text-scroll" for="btn-work_types-{{item.id}}">{{ item.name | capitalize}}</label>
                </div>
                {% endfor %}
                </div>
            </div>
        </div>
    </div>
    <div class="card card-fixed mx-2 d-flex flex-column scrollable-card">
        <div class="card-header text-center">
            <div class="d-flex justify-content-between align-items-center">
                <div>{{ "Permissible Work"}}</div>
                <span class="badge bg-dark" id="permissible-works-count">{{permissible_works|length}}</span>
            </div>
        </div>
        <div class="card-body d-flex flex-column">
            <div class="overflow-auto flex-fill scrollable-body">
                <div class="d-grid gap-2" id="permissible-works-container">
                {% for item in permissible_works %}
                    <div class="radio-row">
                        <input type="radio" class="btn-check" name="permissible_works" id="btn-permissible_works-{{item.id}}" autocomplete="off" value="{{item.id}}" data-id="{{item.id}}" data-group="permissible_works" data-label="{{item.name | capitalize}}">
                        <label class="btn btn-outline-dark btn-sm full-width-label btn-text-scroll" for="btn-permissible_works-{{item.id}}">{{ item.name | capitalize}}</label>
                    </div>
                {% endfor %}
                </div>
            </div>
        </div>
    </div>
    <div class="card border border-2 border-primary mx-2 d-flex flex-column yuktdhara-card" id="yuktdhara-card">
        <div class="card-header text-center bg-primary text-white">Yuktdhara Dropdown Selections</div>
        <div class="card-body d-flex flex-column">
            <div class="d-grid gap-2 flex-fill">
                <div class="form-floating">
                    <input type="text" name="gaw" id="gaw" class="form-control scrollable-input" placeholder="GAW/Non-GAW" readonly>
                    <label for="gaw" class="fs-7">GAW/Non-GAW</label>
                </div>
                <div class="form-floating">
                    <input type="text" name="master_catgory" id="master_catgory" class="form-control scrollable-input" placeholder="Master Category" readonly>
                    <label for="master_catgory" class="fs-7">Master Category</label>
                </div>
                <div class="form-floating">
                    <input type="text" name="major_scheduled_category" id="major_scheduled_category" class="form-control scrollable-input" placeholder="Major Scheduled Category" readonly>
                    <label for="major_scheduled_category" class="fs-7">Major Scheduled Category</label>
                </div>
                <div class="form-floating">
                    <input type="text" name="beneficiary_type" id="beneficiary_type" class="form-control scrollable-input" placeholder="Beneficiary Type" readonly>
                    <label for="beneficiary_type" class="fs-7">Beneficiary Type</label>
                </div>
                <div class="form-floating">
                    <input type="text" name="activity_type" id="activity_type" class="form-control scrollable-input" placeholder="Activity Type" readonly>
                    <label for="activity_type" class="fs-7">Activity Type</label>
                </div>
                <div class="form-floating">
                    <input type="text" name="work_type" id="work_type" class="form-control scrollable-input" placeholder="Work Type" readonly>
                    <label for="work_type" class="fs-7">Work Type</label>
                </div>
                <div class="form-floating">
                    <input type="text" name="permissible_work" id="permissible_work" class="form-control scrollable-input" placeholder="Permissible Works" readonly>
                    <label for="permissible_work" class="fs-7">Permissible Works</label>
                </div>
            </div>
        </div>
    </div> 
</div>

<style>
/* Loader overlay */
#loaderOverlay {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(255,255,255,0.75);
    z-index: 2000;
    backdrop-filter: blur(1px);
}
#loaderOverlay.show {
    display: flex;
}
.loader-spinner {
    width: 3rem;
    height: 3rem;
    border-radius: 50%;
    border: .35rem solid #e9ecef;
    border-top-color: #0d6efd;
    animation: spin .8s linear infinite;
}
@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Full width labels for second row cards */
.full-width-label {
    width: 100% !important;
    text-align: center !important;
    white-space: nowrap !important;
    min-height: 38px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
}

/* Radio row styling for second row only */
.radio-row {
    display: flex;
    align-items: stretch;
    min-height: 38px;
}

.radio-row input.btn-check {
    flex-shrink: 0;
    margin-right: 0;
}

.radio-row label {
    flex: 1;
}

/* Scrollable inputs in yuktdhara card */
.scrollable-input {
    overflow-x: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    white-space: nowrap;
}

.scrollable-input::-webkit-scrollbar {
    display: none;
}

/* Disabled radio button styling */
.btn-check:disabled + .btn {
    cursor: not-allowed;
}

.btn-check:disabled:not(:checked) + .btn,
.btn-disabled {
    opacity: 0.45;
    background-color: #f8f9fa;
    border-color: #dee2e6;
    color: #212529;
}

#clusters-container .btn-check:disabled + .btn,
#clusters-container .btn-check:disabled:not(:checked) + .btn {
    opacity: 1;
    background-color: #fff;
    border-color: #212529;
    color: #212529;
}

.btn-text-scroll {
    display: flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
    overflow-x: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.btn-text-scroll::-webkit-scrollbar {
    display: none;
}

.search-container {
    display: flex;
    align-items: center;
    justify-content: center;
    transition: min-height 0.3s ease, align-items 0.3s ease;
}

.search-container.searched {
    min-height: 10vh;
    align-items: flex-start;
}

.search-box {
    width: 100%;
    max-width: 600px;
    position: relative;
}

.search-input {
    width: 100%;
    padding: 15px 50px 15px 20px;
    border: 2px solid #ddd;
    border-radius: 25px;
    font-size: 16px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.search-input:focus {
    outline: none;
    border-color: #0d6efd;
    box-shadow: 0 4px 15px rgba(13, 110, 253, 0.3);
}

.search-btn {
    position: absolute;
    right: 5px;
    top: 50%;
    transform: translateY(-50%);
    background: #0d6efd;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    color: #fff;
    cursor: pointer;
    transition: background-color 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.search-btn:hover {
    background: #0b5ed7;
}

.search-btn:disabled {
    background: #6c757d;
    cursor: not-allowed;
}

/* Filter badges */
.filter-badge {
    background-color: var(--bs-secondary);
    color: white;
    border: none;
    padding: 0.25rem 0.5rem;
    border-radius: 0.375rem;
    font-size: 0.55rem;
    display: inline-flex;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.15s ease-in-out;
}

.filter-badge:hover {
    background-color: var(--bs-danger);
}

.filter-badge.locked-filter {
    cursor: default;
}

.filter-badge.locked-filter:hover {
    background-color: var(--bs-secondary);
}

.filter-badge .remove-filter {
    background: none;
    border: none;
    color: white;
    padding: 0;
    margin-left: 0.25rem;
    cursor: pointer;
    font-size: 0.875rem;
}

/* Text centering for first row labels */
.btn-group .btn {
    text-align: center !important;
}


/* Second row layout improvements */
#second-row {
    min-height: 400px;
}

/* Yuktdhara card improvements */
.yuktdhara-card {
    width: 300px;
    min-width: 300px;
    max-width: 350px;
    max-height: 550px;
    min-height: 550px;
}



/* Scrollable cards specific styling */
.scrollable-card {
    max-height: 550px;
}

.scrollable-card .scrollable-body {
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
    -ms-overflow-style: none;
}

.scrollable-card .scrollable-body::-webkit-scrollbar {
    display: none;
}

/* Ensure Yuktdhara card grows with content */
.yuktdhara-card .card-body {
    min-height: 300px;
    max-height: 500px;
}

.scrollable-card .card-body {
    max-height: 500px;
}

/* Hidden items for search */
.search-hidden {
    display: none !important;
}

/* Responsive adjustments */
@media (max-width: 1200px) {
    .yuktdhara-card {
        width: 280px;
        min-width: 280px;
    }
}

@media (max-width: 992px) {
    #second-row {
        flex-wrap: wrap;
    }
    
    .yuktdhara-card {
        width: 100%;
        max-width: none;
        order: -1;
    }
}

#clusters-container label{
    cursor: not-allowed;
}
#clusters-container:hover{
    cursor: not-allowed;
}
</style>

<!-- Loader markup -->
<div id="loaderOverlay" role="status" aria-live="polite" aria-label="Loading">
    <div class="loader-spinner" aria-hidden="true"></div>
    <div class="ms-3 fw-semibold text-primary">Filtering…</div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const FILTER_ENDPOINT = '/dashboard/activity_identification/filter';
    const SEARCH_ENDPOINT = '/dashboard/activity_identification/search';
    let allSelections = new Set(); // Track all selections (manual + auto)

    const CHECKBOX_GROUPS = new Set(['clusters', 'ridges', 'slopes', 'water_works', 'location_specifics']);
    const LOCKED_GROUPS = new Set(['clusters']);
    const STACKED_GROUPS = new Set(['location_specifics', 'major_scheduled_category', 'work_types', 'permissible_works']);

    // Map filter groups to display fields
    const GROUP_TO_DISPLAY_FIELD = {
        nature_of_works: 'gaw',
        categories: 'master_catgory',
        major_scheduled_category: 'major_scheduled_category',
        beneficiaries: 'beneficiary_type',
        activity_types: 'activity_type',
        work_types: 'work_type',
        permissible_works: 'permissible_work'
    };

    // Map groups to containers
    const GROUP_TO_CONTAINER = {
        categories: 'categories-container',
        major_scheduled_category: 'major-scheduled-container',
        beneficiaries: 'beneficiaries-container',
        activity_types: 'activities-container',
        work_types: 'work-types-container',
        permissible_works: 'permissible-works-container',
        location_specifics: 'land-types-container',
        ridges: 'ridges-container',
        clusters: 'clusters-container',
        slopes: 'slopes-container',
        water_works: 'water-works-container'
    };

    const LABEL_FIELDS = {
        categories: 'name',
        major_scheduled_category: 'name',
        beneficiaries: 'name',
        activity_types: 'short_name',
        work_types: 'name',
        permissible_works: 'name',
        location_specifics: 'name',
        ridges: 'name',
        clusters: 'name',
        slopes: 'name',
        water_works: 'name'
    };

    // Map groups to count elements
    const GROUP_TO_COUNT = {
        major_scheduled_category: 'major-scheduled-count',
        work_types: 'work-types-count',
        permissible_works: 'permissible-works-count',
        location_specifics: 'land-types-count'
    };

    const filterSnapshot = {};
    const SEARCH_TARGET_GROUPS = ['permissible_works', 'work_types', 'major_scheduled_category'];
    let activeSearchResult = null;
    let activeSearchTerm = '';
    let searchDebounceTimer = null;
    let currentSearchAbort = null;
    let permissibleSearchInput = null;
    let permissibleSearchBtn = null;
    let searchContainerEl = null;

    const SUPPRESSED_AUTO = {
        fill: new Set(),
        select: new Set()
    };

    const suppressGroup = (group) => {
        if (!group || LOCKED_GROUPS.has(group)) return;
        SUPPRESSED_AUTO.fill.add(group);
        SUPPRESSED_AUTO.select.add(group);
    };

    const releaseGroup = (group) => {
        if (!group) return;
        SUPPRESSED_AUTO.fill.delete(group);
        SUPPRESSED_AUTO.select.delete(group);
    };

    // Initialize display fields
    Object.values(GROUP_TO_DISPLAY_FIELD).forEach(id => {
        const el = document.getElementById(id);
        if (el) el.value = '?';
    });

    // Loader management
    const overlay = document.getElementById('loaderOverlay');
    let inflight = 0;

    function showLoader() {
        inflight++;
        if (inflight === 1) {
            overlay.classList.add('show');
            document.body.setAttribute('aria-busy', 'true');
        }
    }
    
    function hideLoader() {
        inflight = Math.max(0, inflight - 1);
        if (inflight === 0) {
            overlay.classList.remove('show');
            document.body.removeAttribute('aria-busy');
        }
    }

    // Helper functions
    const getLabelText = (input) => input.getAttribute('data-label') || '';

    // Applied filters management
    const appliedFiltersContainer = document.getElementById('applied-filters-container');
    const noFiltersText = document.getElementById('no-filters-text');
    const clearAllBtn = document.getElementById('clear-all-filters');

    function updateAppliedFilters(selections) {
        appliedFiltersContainer.innerHTML = '';
        let hasFilters = false;

        // Show ALL selections, not just manual ones
        Object.entries(selections).forEach(([group, data]) => {
            if (data.ids.length > 0) {
                hasFilters = true;
                data.labels.forEach((label, index) => {
                    const badge = document.createElement('span');
                    badge.className = 'filter-badge';
                    if (LOCKED_GROUPS.has(group)) {
                        badge.textContent = label;
                        badge.classList.add('locked-filter');
                    } else {
                        badge.innerHTML = `
                            ${label}
                            <button type="button" class="remove-filter" data-group="${group}" data-id="${data.ids[index]}" aria-label="Remove ${label} filter">
                                ×
                            </button>
                        `;
                    }
                    appliedFiltersContainer.appendChild(badge);
                });
            }
        });

        noFiltersText.style.display = hasFilters ? 'none' : 'inline';
        const filterRow = document.getElementById('applied-filters-row');
        if (filterRow) {
            filterRow.classList.toggle('invisible', !hasFilters);
        }
    }

    // Handle filter removal
    appliedFiltersContainer.addEventListener('click', (e) => {
        if (e.target.classList.contains('remove-filter')) {
            const group = e.target.getAttribute('data-group');
            if (LOCKED_GROUPS.has(group)) {
                return;
            }
            const id = e.target.getAttribute('data-id');
            
            const radioBtn = document.querySelector(`input[data-group="${group}"][data-id="${id}"]`);
            if (radioBtn) {
                radioBtn.checked = false;
                allSelections.delete(`${group}_${id}`);
                suppressGroup(group);
                onChange();
            }
        }
    });

    // Clear all filters
    clearAllBtn.addEventListener('click', () => {
        document.querySelectorAll('input.btn-check[data-group]').forEach(input => {
            input.checked = false;
        });
        allSelections.clear();
        SUPPRESSED_AUTO.fill.clear();
        SUPPRESSED_AUTO.select.clear();

        if (permissibleSearchInput) {
            permissibleSearchInput.value = '';
        }
        activeSearchResult = null;
        activeSearchTerm = '';
        if (searchDebounceTimer) {
            clearTimeout(searchDebounceTimer);
            searchDebounceTimer = null;
        }
        if (currentSearchAbort) {
            currentSearchAbort.abort();
            currentSearchAbort = null;
        }
        restoreSearchTargets({ skipDisplayUpdate: true });
        if (permissibleSearchBtn) {
            permissibleSearchBtn.disabled = true;
        }
        if (searchContainerEl) {
            searchContainerEl.classList.remove('searched');
        }

        onChange();
    });

    // Collect selections
    const collectSelections = () => {
        const result = {};
        const radios = document.querySelectorAll('input.btn-check[data-group]');
        
        radios.forEach(input => {
            const group = input.getAttribute('data-group');
            if (!result[group]) {
                result[group] = { ids: [], labels: [] };
            }
        });
        
        radios.forEach(input => {
            const group = input.getAttribute('data-group');
            if (input.checked) {
                const id = parseInt(input.getAttribute('data-id'), 10);
                if (!Number.isNaN(id)) {
                    result[group].ids.push(id);
                    result[group].labels.push(getLabelText(input));
                }
            }
        });
        
        return result;
    };

    // Update display fields
    const updateDisplayFields = (selections, autoFillData = {}) => {
        Object.entries(GROUP_TO_DISPLAY_FIELD).forEach(([group, fieldId]) => {
            const field = document.getElementById(fieldId);
            if (!field) return;
            
            let value = '?';
            const labels = (selections[group]?.labels || []);
            
            if (labels.length > 0) {
                value = labels[0];
            } else if (autoFillData[group]) {
                value = autoFillData[group].name;
            }
            
            field.value = value;
        });
    };

    const buildDisplayLabel = (rawValue) => {
        if (!rawValue) return '';
        const text = rawValue.toString();
        return text.charAt(0).toUpperCase() + text.slice(1);
    };

    const renderGroup = (group, items, labelField) => {
        const containerId = GROUP_TO_CONTAINER[group];
        if (!containerId) return;

        const container = document.getElementById(containerId);
        if (!container) return;

        const previouslyChecked = new Set(
            Array.from(container.querySelectorAll('input.btn-check:checked'))
                .map(input => parseInt(input.getAttribute('data-id'), 10))
                .filter(id => !Number.isNaN(id))
        );

        const previousSelectionKeys = [];
        allSelections.forEach(key => {
            if (key.startsWith(`${group}_`)) {
                previousSelectionKeys.push(key);
            }
        });

        container.innerHTML = '';
        const stamp = Date.now();
        const isStacked = STACKED_GROUPS.has(group);
        const inputType = CHECKBOX_GROUPS.has(group) ? 'checkbox' : 'radio';
        const labelKey = labelField || LABEL_FIELDS[group] || 'name';

        const newlyCheckedIds = new Set();

        items.forEach((item, index) => {
            const labelValue = buildDisplayLabel(item[labelKey] ?? item.name ?? '');
            const identifier = `${group}_${stamp}_${index}`;
            const inputId = `btn${identifier}`;
            const optionId = parseInt(item.id, 10);
            if (Number.isNaN(optionId)) {
                return;
            }
            const wasChecked = previouslyChecked.has(optionId);
            const isDisabled = Boolean(item.disabled);
            const isLocked = LOCKED_GROUPS.has(group);
            const shouldCheck = wasChecked && !isDisabled;

            const input = document.createElement('input');
            input.type = inputType;
            input.className = 'btn-check';
            input.name = group;
            input.id = inputId;
            input.autocomplete = 'off';
            input.value = optionId;
            input.setAttribute('data-id', optionId);
            input.setAttribute('data-group', group);
            input.setAttribute('data-label', labelValue);
            input.checked = shouldCheck;
            input.disabled = isDisabled;
            if (isLocked) {
                input.setAttribute('data-locked', 'true');
            } else {
                input.removeAttribute('data-locked');
            }

            if (input.checked) {
                newlyCheckedIds.add(optionId);
            }

            const label = document.createElement('label');
            label.className = isStacked
                ? 'btn btn-outline-dark btn-sm full-width-label'
                : 'btn btn-outline-dark btn-sm text-center';
            label.setAttribute('for', inputId);
            label.textContent = labelValue;

            label.classList.add('btn-text-scroll');

            if (isDisabled && !isLocked) {
                label.classList.add('btn-disabled');
            }

            if (isStacked) {
                const row = document.createElement('div');
                row.className = 'radio-row';
                row.appendChild(input);
                row.appendChild(label);
                container.appendChild(row);
            } else {
                container.appendChild(input);
                container.appendChild(label);
            }
        });

        const newSelectionKeys = new Set();
        newlyCheckedIds.forEach(id => {
            const key = `${group}_${id}`;
            newSelectionKeys.add(key);
            allSelections.add(key);
        });

        previousSelectionKeys.forEach(key => {
            if (!newSelectionKeys.has(key)) {
                allSelections.delete(key);
            }
        });
    };

    const storeSnapshot = (group, items, count) => {
        filterSnapshot[group] = {
            items: items.map(item => ({ ...item })),
            count: typeof count === 'number'
                ? count
                : items.filter(opt => !opt.disabled).length
        };

        const effectiveCount = filterSnapshot[group].count;
        if (effectiveCount <= 1) {
            releaseGroup(group);
        }
    };

    const applySearchResult = (payload, { skipDisplayUpdate = false } = {}) => {
        if (!payload) return;

        SEARCH_TARGET_GROUPS.forEach(group => {
            if (!payload[group]) return;
            const labelField = LABEL_FIELDS[group] || 'name';

            const baseline = filterSnapshot[group];
            const baseEnabled = baseline ? new Set(baseline.items.filter(opt => !opt.disabled).map(opt => opt.id)) : null;
            const clonedItems = payload[group].map(item => {
                const option = { ...item };
                if (baseEnabled && !baseEnabled.has(option.id)) {
                    option.disabled = true;
                }
                return option;
            });

            renderGroup(group, clonedItems, labelField);

            const countId = GROUP_TO_COUNT[group];
            if (countId) {
                const enabledCount = clonedItems.filter(opt => !opt.disabled).length;
                updateCount(countId, enabledCount);
            }
        });

        if (!skipDisplayUpdate) {
            const selections = collectSelections();
            updateDisplayFields(selections);
            updateAppliedFilters(selections);
        }
    };

    const restoreSearchTargets = ({ skipDisplayUpdate = false } = {}) => {
        SEARCH_TARGET_GROUPS.forEach(group => {
            const snapshot = filterSnapshot[group];
            if (!snapshot) return;
            const labelField = LABEL_FIELDS[group] || 'name';
            const clonedItems = snapshot.items.map(item => ({ ...item }));
            renderGroup(group, clonedItems, labelField);

            const countId = GROUP_TO_COUNT[group];
            if (countId) {
                updateCount(countId, snapshot.count);
            }
        });

        if (!skipDisplayUpdate) {
            const selections = collectSelections();
            updateDisplayFields(selections);
            updateAppliedFilters(selections);
        }
    };

    const finalizeSync = (autoFillData = {}) => {
        const updatedSelections = collectSelections();
        updateDisplayFields(updatedSelections, autoFillData);
        updateAppliedFilters(updatedSelections);

        if (activeSearchResult && activeSearchTerm.length >= 3) {
            applySearchResult(activeSearchResult, { skipDisplayUpdate: true });
            const selectionsAfterSearch = collectSelections();
            updateDisplayFields(selectionsAfterSearch, autoFillData);
            updateAppliedFilters(selectionsAfterSearch);
        }
    };

    // Update counts
    const updateCount = (countId, count) => {
        const countEl = document.getElementById(countId);
        if (countEl) {
            countEl.textContent = count || 0;
        }
    };

    // Update dynamic elements
    const updateDynamicElements = (data) => {
        const groupsToUpdate = [
            ['categories', 'name'],
            ['beneficiaries', 'name'],
            ['activity_types', 'short_name'],
            ['major_scheduled_category', 'name'],
            ['work_types', 'name'],
            ['permissible_works', 'name'],
            ['location_specifics', 'name'],
            ['ridges', 'name'],
            ['slopes', 'name'],
            ['water_works', 'name'],
            ['clusters', 'name'],
        ];

        groupsToUpdate.forEach(([group, labelField]) => {
            if (data[group]) {
                const items = data[group].map(item => ({ ...item }));
                renderGroup(group, items, labelField);
                storeSnapshot(group, items, data[`${group}_count`]);
            }
        });

        if (data.major_scheduled_category) {
            updateCount('major-scheduled-count', data.major_scheduled_category_count);
        }

        if (data.work_types) {
            updateCount('work-types-count', data.work_types_count);
        }

        if (data.permissible_works) {
            updateCount('permissible-works-count', data.permissible_works_count);
        }

        if (data.location_specifics) {
            updateCount('land-types-count', data.location_specifics_count);
        }
    };

    const handleAutoSelect = (autoSelectData) => {
        Object.entries(autoSelectData).forEach(([group, ids]) => {
            const snapshot = filterSnapshot[group];
            const forceSelect = snapshot && snapshot.count <= 1;

            if (forceSelect) {
                SUPPRESSED_AUTO.select.delete(group);
            }

            if (SUPPRESSED_AUTO.select.has(group)) {
                return;
            }
            const normalizedIds = Array.isArray(ids) ? ids : [ids];
            const targetIds = new Set(
                normalizedIds
                    .map(value => parseInt(value, 10))
                    .filter(value => !Number.isNaN(value))
            );
            const inputs = document.querySelectorAll(`input[data-group="${group}"]`);

            inputs.forEach(input => {
                const id = parseInt(input.getAttribute('data-id'), 10);
                if (Number.isNaN(id)) return;
                const shouldCheck = targetIds.has(id);
                input.checked = shouldCheck;

                const key = `${group}_${id}`;
                if (shouldCheck) {
                    allSelections.add(key);
                } else {
                    allSelections.delete(key);
                }
            });
        });
    };

    // Handle auto-fill
    const handleAutoFill = (autoFillData) => {
        Object.entries(autoFillData).forEach(([group, data]) => {
            const snapshot = filterSnapshot[group];
            const forceFill = snapshot && snapshot.count <= 1;

            if (forceFill) {
                SUPPRESSED_AUTO.fill.delete(group);
            }

            if (SUPPRESSED_AUTO.fill.has(group)) {
                return;
            }
            const currentRadio = document.querySelector(`input[data-group="${group}"]:checked`);
            if (!currentRadio) {
                const radioToSelect = document.querySelector(`input[data-group="${group}"][data-id="${data.id}"]`);
                if (radioToSelect && !radioToSelect.disabled) {
                    radioToSelect.checked = true;
                    allSelections.add(`${group}_${data.id}`);
                }
            }
        });
    };

    // Debounced filtering
    let debounceTimer = null;
    let currentAbort = null;

    const debouncedFilter = (selections) => {
        if (debounceTimer) clearTimeout(debounceTimer);
        debounceTimer = setTimeout(async () => {
            try {
                const filterData = {};
                
                Object.keys(selections).forEach(group => {
                    const ids = selections[group].ids;
                    if (ids && ids.length > 0) {
                        filterData[group] = ids;
                    }
                });

                if (currentAbort) currentAbort.abort();
                currentAbort = new AbortController();

                showLoader();

                const response = await fetch(FILTER_ENDPOINT, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest',
                    },
                    credentials: 'same-origin',
                    signal: currentAbort.signal,
                    body: JSON.stringify(filterData)
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        updateDynamicElements(result.data);

                        const autoSelect = result.data.auto_select || {};
                        const autoFill = result.data.auto_fill || {};
                        const hasAutoSelect = Object.keys(autoSelect).length > 0;
                        const hasAutoFill = Object.keys(autoFill).length > 0;

                        const performFinalize = () => {
                            finalizeSync(autoFill);
                        };

                        if (hasAutoSelect || hasAutoFill) {
                            setTimeout(() => {
                                if (hasAutoSelect) {
                                    handleAutoSelect(autoSelect);
                                }
                                if (hasAutoFill) {
                                    handleAutoFill(autoFill);
                                }
                                performFinalize();
                            }, 0);
                        } else {
                            performFinalize();
                        }
                    } else {
                        console.error('Filter error:', result.error);
                    }
                } else {
                    console.error('HTTP error:', response.status);
                }

            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Fetch error:', error);
                }
            } finally {
                hideLoader();
            }
        }, 300);
    };

    // Handle changes
    const onChange = () => {
        const selections = collectSelections();
        updateDisplayFields(selections);
        updateAppliedFilters(selections);
        debouncedFilter(selections);
    };

    // Track selections
    document.addEventListener('pointerdown', (evt) => {
        let input = null;
        if (evt.target.matches('input.btn-check[data-group]')) {
            input = evt.target;
        } else if (evt.target.matches('label[for]')) {
            const forId = evt.target.getAttribute('for');
            const el = document.getElementById(forId);
            if (el && el.matches('input.btn-check[data-group]')) input = el;
        }
        
        if (input && input.type === 'radio' && input.checked && !input.disabled) {
            input.dataset.wasChecked = 'true';
        }

        if (input && input.dataset.locked === 'true') {
            evt.preventDefault();
            evt.stopPropagation();
        }
    });

    document.addEventListener('click', (evt) => {
        let input = null;
        if (evt.target.matches('input.btn-check[data-group]')) {
            input = evt.target;
        } else if (evt.target.matches('label[for]')) {
            const forId = evt.target.getAttribute('for');
            const el = document.getElementById(forId);
            if (el && el.matches('input.btn-check[data-group]')) input = el;
        }
        
        if (input) {
            if (input.dataset.locked === 'true') {
                evt.preventDefault();
                return;
            }
            if (input.dataset.wasChecked === 'true') {
                input.checked = false;
                delete input.dataset.wasChecked;
                const key = `${input.getAttribute('data-group')}_${input.getAttribute('data-id')}`;
                allSelections.delete(key);
                input.dispatchEvent(new Event('change', { bubbles: true }));
                evt.preventDefault();
            } else {
                delete input.dataset.wasChecked;
                if (input.checked) {
                    const key = `${input.getAttribute('data-group')}_${input.getAttribute('data-id')}`;
                    allSelections.add(key);
                }
            }
        }
    });

    // Handle radio button changes
    document.addEventListener('change', (evt) => {
        const target = evt.target;
        if (target && target.matches('input.btn-check[data-group]')) {
            const key = `${target.getAttribute('data-group')}_${target.getAttribute('data-id')}`;
            if (target.checked) {
                allSelections.add(key);
                releaseGroup(target.getAttribute('data-group'));
            } else {
                allSelections.delete(key);
                suppressGroup(target.getAttribute('data-group'));
            }
            onChange();
        }
    });

    const performSearch = async (term) => {
        if (currentSearchAbort) {
            currentSearchAbort.abort();
        }

        currentSearchAbort = new AbortController();

        try {
            showLoader();

            const response = await fetch(SEARCH_ENDPOINT, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest',
                },
                credentials: 'same-origin',
                signal: currentSearchAbort.signal,
                body: JSON.stringify({ search: term })
            });

            if (response.ok) {
                const result = await response.json();
                if (result.success) {
                    activeSearchResult = result.data || {};
                    applySearchResult(activeSearchResult);
                } else {
                    console.error('Search error:', result.error);
                    activeSearchResult = null;
                    restoreSearchTargets();
                }
            } else {
                console.error('Search HTTP error:', response.status);
                activeSearchResult = null;
                restoreSearchTargets();
            }
        } catch (error) {
            if (error.name !== 'AbortError') {
                console.error('Search fetch error:', error);
                activeSearchResult = null;
                restoreSearchTargets();
            }
        } finally {
            hideLoader();
            currentSearchAbort = null;
        }
    };

    permissibleSearchInput = document.getElementById('permissible-search');
    permissibleSearchBtn = document.getElementById('permissible-search-btn');
    searchContainerEl = document.getElementById('permissible-search-card');

    if (permissibleSearchInput) {
        permissibleSearchInput.addEventListener('input', (evt) => {
            const term = evt.target.value.trim();
            activeSearchTerm = term;

            if (searchDebounceTimer) {
                clearTimeout(searchDebounceTimer);
            }

            if (permissibleSearchBtn) {
                permissibleSearchBtn.disabled = term.length < 3;
            }

            if (term.length >= 3) {
                if (searchContainerEl) {
                    searchContainerEl.classList.add('searched');
                }
            } else {
                if (searchContainerEl) {
                    searchContainerEl.classList.remove('searched');
                }
            }

            if (term.length === 0) {
                activeSearchResult = null;
                if (currentSearchAbort) {
                    currentSearchAbort.abort();
                    currentSearchAbort = null;
                }
                restoreSearchTargets();
                return;
            }

            if (term.length < 3) {
                activeSearchResult = null;
                if (currentSearchAbort) {
                    currentSearchAbort.abort();
                    currentSearchAbort = null;
                }
                restoreSearchTargets();
                return;
            }

            searchDebounceTimer = setTimeout(() => {
                performSearch(term);
            }, 400);
        });
    }

    if (permissibleSearchBtn && permissibleSearchInput) {
        permissibleSearchBtn.addEventListener('click', () => {
            const term = permissibleSearchInput.value.trim();
            if (term.length >= 3) {
                performSearch(term);
            }
        });
    }

    // Initial sync
    const initialSelections = collectSelections();
    updateDisplayFields(initialSelections);
    updateAppliedFilters(initialSelections);
    debouncedFilter(initialSelections);
});
</script>
{% endblock %}
